# C++20 Coroutines

## References

- [1] [Lewis Baker introduction to coroutines](https://lewissbaker.github.io/) : slightly out-of-date, but very clear and complete on the coroutine TS written beween 2017 and 2020. Lewis Baker is the author of the library [*cppcoro*](https://github.com/lewissbaker/cppcoro).
  - [1.1] [Coroutine theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory)
  - [1.2] [C++ Coroutines: Understanding operator `co_await`](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)
  - [1.3] [C++ Coroutines: Understanding the promise type](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)
  - [1.4] [C++ Coroutines: Understanding Symmetric Transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer)
- [2] [Raymond Chen's 3 coroutine series](https://devblogs.microsoft.com/oldnewthing/20210504-01/?p=105178)
- [3] [My tutorial and take on C++20 coroutines, from David Mazières](https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html)
- [4] [C++ for C# developpers Part 36 - Coroutines](https://www.jacksondunstan.com/articles/6311)
- [5] [cppreference.com coroutines page](https://en.cppreference.com/w/cpp/language/coroutines)

## Overview

A coroutine is a resumable function, i.e. a function that can be suspended and resumed. For this to be possible, the state of the function including its resume point must be preserved in some data structure during suspensions. There are two avenues to do this: stackful coroutines, where a coroutine has its own stack and leaving a coroutine to resume it later means switching stacks (see for instance coroutines implemented with `setjmp`/`longjmp`); and stackless coroutines, where coroutine states are special purpose data structures stored on the heap. Stackful coroutines can be suspended and resumed from inside subfunction calls, whereas stackless coroutines cannot, since the fixed-size data structure associated to a coroutine can only store the state of this function and not data associated to an arbitrary number of function calls.

C++20 implements stackless coroutines. Coroutine states are managed by the compiler and not directly visible from the code. Part of the coroutine state is an object than can nevertheless be customized: the *promise object*.

A regular function becomes a coroutine and is compiled as such as soon as it uses a coroutine operation : `co_await`, `co_return` or `co_yield`. Therefore the impossibility to suspend/resume from a regular function called from a coroutine is baked into the syntax and semantics.

Behavior of a coroutine is largely defined by its *return type*. The return object type must follow some conventions such as defining the *promise type* as a subtype of itself:

~~~C++
struct return_object {
  struct promise_type {
    //...
  };
};
~~~

Some `promise_type` standard methods are called when the coroutine invokes `co_await`, `co_yield` or `co_return`; a predefined method is also invoked for the creation of the return object itself.

Similarly to a promise/future relation, the promise object is more or less the interface of the coroutine, whereas the return object is what is seen by the code that started the coroutine (since this code obtains the return object). The return object can easily be given access to the promise object, and through that, to information about the state of the coroutine or to what it produced.

In some contexts, a *coroutine handle* can be obtained when a coroutine is suspended. This acts as a pointer to the coroutine state, and has a `resume()` method that enables to resume the coroutine at the suspension point recorded in its state. A coroutine handle can also be explictly constructed from a promise object or from a raw pointer to the coroutine state.

It may be surprising that, in the coroutine syntax, a coroutine does not explicitly returns its return object. The code that performs this is generated by the compiler.

### In short

- return type of coroutine = return object ≠ promise object

- coroutine handle ≈ pointer to coroutine state

- promise object ⊂ coroutine state

- type of promise object defined in type of return object, as a subtype `promise_type` of this object.

## Coroutine handle, coroutine state, promise object, return object

One can obtain a *coroutine handle* from a *promise object* `p` because the address of the coroutine state can be deduced from the address of the *promise object*, which is at a fixed offset in the coroutine state. This is the job of the promise method `std::coroutine_handle<promise_type>::from_promise()`: `p.from_promise()` produces the handle.
Conversely, from a coroutine handle `h` having type `std::coroutine_handle<promise_type>`, `h.promise()` returns a reference to the promise object. The promise type `promise_type` must be specified for this to work; `.promise()` cannot be used on a `std::coroutine_handle<>` handle (which any handle can be converted to).

The return object is created by a call to promise method `get_return_object()` on the promise object included in the coroutine state, when the coroutine is called and before entering in its scope.

Although the return object type defines the promise object type in its namespace, both objects are unrelated.

In example 2 of [3], the promise method `get_return_object()` puts a *coroutine handle* obtained with `this->from_promise()` in the return object. This is a common technique with many variations that enables access to the coroutine state from the return object. This access can be used to resume the coroutine (with `h->resume()`, `h` being the stored handle), or to access values that are stored by the coroutine in the promise object.

One such variation is to include in the return object a conversion operator to the coroutine handle type. This way, the calling code can access the handle and through it, the promise object:

~~~C++
  // in return object class
  std::coroutine_handle<promise_type> h;
  operator std::coroutine_handle<promise_type>() const { return h; }

  // in calling code:
  // start the coroutine and retrieve a handle on it
  std::coroutine_handle<promise_type> h = my_coroutine();
  // or, using an implicit cast from
  // std::coroutine_handle<promise_type>
  // to std::coroutine_handle<>
  std::coroutine_handle<> h = my_coroutine();
~~~

An alternative, and maybe more explicit design, would let the calling code retrieve the full return object, and internal methods of the return object access the promise through the handle `h`.

## Coroutine start-up sequence

From [5] :
> When a coroutine begins execution, it performs the following:
>
>  - allocates the coroutine state object using operator `new`
>  - copies all function parameters to the coroutine state: by-value parameters are moved or copied, by-reference parameters remain references (and so may become dangling if the coroutine is resumed after the lifetime of referred object ends)
>  - calls the constructor for the promise object. If the promise type has a constructor that takes all coroutine parameters, that constructor is called, with post-copy coroutine arguments. Otherwise the default constructor is called.
>  - calls `promise.get_return_object()` and keeps the result in a local variable. The result of that call will be returned to the caller when the coroutine first suspends. Any exceptions thrown up to and including this step propagate back to the caller, they are not stored in the promise.
>  - calls `promise.initial_suspend()` and `co_awaits` its result. Typical Promise types either return a `suspend_always`, for lazily-started coroutines, or `suspend_never`, for eagerly-started coroutines.
>  - when `co_await promise.initial_suspend()` resumes, starts executing the body of the coroutine.

## Methods in the promise type

~~~C++

struct return_object
{
  struct promise_type
  {
    std::exception_ptr exception;
    using handle_type = std::coroutine_handle<promise_type>;

    // called upon first coroutine call, before entering in
    //the coroutine code, to create the return object
    // mandatory
    return_object get_return_object();

    // returns an awaiter object that determines whether
    // the coroutine is suspended before start.
    // is mandatory
    std::suspend_always initial_suspend()
    {
      return {};
    }
    // returns an awaiter object that determines whether
    // the coroutine is suspended before exiting (co_return or end of scope).
    // otherwise its state is immediately destroyed.
    // is mandatory
    std::suspend_always final_suspend() noexcept
    {
      return {};
    }
    // called when an exception is thrown inside the coroutine.
    // mandatory only if the corresponding coroutine statement is used
    void unhandled_exception()
    {
      exception = std::current_exception();
    }
    // called when using co_yield from inside the coroutine.
    // mandatory only if the corresponding coroutine statement is used
    template<std::convertible_to<T> From> // C++20 concept
    std::suspend_always yield_value(From &&from)
    {
      value = std::forward<From>(from);
      return {};
    }
    void return_void()
    // called
    // - when using co_return without argument in the coroutine, or
    // - when using co_return <expr> with expr having type void, or
    // - at the end of the coroutine scope
    // mandatory only if the corresponding coroutine statement is used (UB otherwise)
    {}

    template<class T> // called when using co_return v, with v of type T, in the coroutine
    // typically stores the value in the promise and somehow signals that a value is available
    // mandatory only if the corresponding coroutine statement is used
    void return_value(T e)
    {}
  };
};
~~~

For `suspend_always` and `suspend_never`, see paragraph about awaiters below.

## Stack behavior when starting / resuming a coroutine

When a coroutine is started, a stack frame is created on the current thread stack just like with a normal function call. This frame is destroyed when this call returns, although the coroutine may live on. For this to work, arguments of the coroutine are copied or moved into the coroutine state when the coroutine is called; otherwise some arguments may be unavailable after a suspend/resume of the coroutine. See [1.1]. Similarly, when the coroutine is resumed from its handle `h` using `h.resume()`, this call is a normal function call that creates a stack frame in the current thread stack, which is then destroyed when / if the call returns.

## `co_return` and `co_yield`

`co_return` (with or without an argument) returns from the coroutine: it is not possible to resume it afterwards. The coroutine may or may not be suspended one last time, depending on the awaiter returned by `p.final_suspend()`, `p` being the promise object. See methods `return_void` and `return_value` of the promise object.

`co_yield` is used to produce a value from within the coroutine, with or without suspending it, and with the possibility to resume the coroutine later. The value produced may for instance be stored in the promise object for later consumption. See method `yield_value` of the promise object.

## `co_await` and awaiter objects

Awaiter objects are used when a coroutine co_awaits. When the expression `co_await a` is encountered, this triggers a logic that creates an *awaiter object* `b`. In the simplest case, `b` is simply equal to `a`. An awaiter must implement methods `await_ready`, `await_suspend` and `await_resume`. The roles of these methods are explained below.

~~~C++
struct Awaiter {
  bool await_ready() const noexcept
  {
    // called first after co_await.
    // If it returns true, the coroutine is ready,
    // it should not be interrupted.
    // In that case the calling coroutine is immediately
    // resumed; state saving / restoring does not occur.
    // if it returns false, the coroutine state is saved
    // and await_suspend is called (see below)
      return false;
  }
  void/bool/std::coroutine_handle<> await_suspend(std::coroutine_handle<> h)
  {
    // after await_ready, if the coroutine is not ready,
    // the call to co_await saves the coroutine state and calls
    // a.await_suspend(h),
    // where h is a handle on the calling coroutine state.
    // h enables to resume the coroutine that co_awaits.
    // `await_suspend` is responsible to store `h`
    // so that the coroutine can be resumed later.
    // `await_suspen` may return nothing, a bool or
    // a coroutine handle.
    // - if it returns bool:
    //   tells whether the coroutine should be suspended.
    // - if it returns a coroutine_handle:
    //   the coroutine corresponding to this handle is
    //   immediately resumed.
  }
  custom_type await_resume() const noexcept
  {
    // determines the value of the the co_await expression
    // when the coroutine is resumed.
    // the return type may be set to whatever type is returned.
  }
};
~~~

`std::suspend_always` and `std::suspend_never` are standard awaiters whose `await_ready` methods return respectively `false` and `true`; whose `await_suspend` and `await_resume` method do nothing. The return type of `await_resume` is `void`.

### Logic to derive the awaiter

To derive the awaiter `b` from `co_await <expr>`, first, an awaitable object is derived, then the awaiter is determined from it:

- if the `promise` object of the coroutine which co_awaits has  a method `await_transform`:
 `awaitable a` is obtained as `promise.await_transform(<expr>)`
otherwise
 `awaitable a = evaluation of <expr>`
- then, if `awaitable a` has an `operator co_await()`, the awaiter `b` is obtained as `a.co_await()`.
otherwise,  the awaiter `b` is `a`.

> See awaiter `GetPromise` of [1] for an example of an awaiter that does not suspend the coroutine (`await_ready` returns false, but `await_suspend` also returns false), and is instead used to enable the coroutine to access its own promise object: `await_suspend` stores the coroutine handle in the awaiter, and `await_resume` converts this into a pointer to the promise object, which it returns. This is used to store a value from the coroutine in the promise, which can then be accessed from the code that started the coroutine through the return object provided it has a copy of the coroutine handle as discussed previously. This technique is however unnecessary as the resulting code roughtly emulates what is done by `co_yield`.

## Generator example

Adapted from [3] (or [5]). The promise type:

~~~C++
template<typename T>
struct generator;

template<class T>
struct generator_promise_type
{
  T value;
  std::exception_ptr exception;
  using handle_type = std::coroutine_handle<generator_promise_type>;
  // defined after generator<T>
  generator<T> get_return_object();
  std::suspend_always initial_suspend() { return {}; }
  std::suspend_always final_suspend() noexcept { return {}; }
  void unhandled_exception() { exception = std::current_exception(); }
  template<std::convertible_to<T> From>
  std::suspend_always yield_value(From &&from)
  {
    value = std::forward<From>(from);
    return {};
  }
  void return_void() {}
};
~~~

The full generator class (which is the coroutine return type) is then as follows.

~~~C++
template<class T> struct generator_promise_type;

template<typename T>
struct generator {
  using promise_type = generator_promise_type<T>;
  using handle_type = std::coroutine_handle<promise_type>;

  generator(handle_type h) : h(h) {}
  ~generator() { h.destroy(); }
  generator(const generator&) = delete;
  generator(generator&&) = default;
  explicit operator bool() {
    fill();
    return !h.done();
    // h.done(): Checks if a suspended coroutine is suspended
    // at its final suspended point.
    // https://en.cppreference.com/w/cpp/coroutine/coroutine_handle/done
  }
  T operator()() {
    fill();
    full = false;
    return std::move(h.promise().value);
  }

private:
  handle_type h;
  bool full = false;

  void fill()
  {
    if (!full)
    {
      h(); // same as h.resume()
      if (h.promise().exception)
      {
        std::rethrow_exception(h.promise().exception);
      }
      full = true;
    }
  }
};

template<class T>
generator<T> generator_promise_type<T>::get_return_object()
{
  return generator<T>(handle_type::from_promise(*this));
}

~~~

Example usage:

~~~C++
generator<unsigned> counter()
{
  for (unsigned i = 0; i < 3; i++) co_yield i;
}

void main()
{
  auto gen = counter();
  while (gen) std::cout << "counter: " << gen() << std::endl;
}
~~~
